Title: Python Workflow 
Date: 2021-06-05 21:00
Category: Workflow
Tags: python, workflow
Summary: My python project workflow.
comment_id: python-workflow
Status: published

After listening to
[Talk Python to Me #314](https://talkpython.fm/episodes/show/314/ask-us-about-modern-python-projects-and-tools),
I decided that I need to update my Python workflow.
I am leaning towards buying
[Modern Python Projects Course](https://training.talkpython.fm/courses/modern-python-projects)
but will probably wait until later in the year when I have some more time.

This post will focus on my workflow on Python projects and packages.
I have a separate workflow for my data analysis.

## History

When I started using Python more regularly, I realized that I needed a process
so that I could create consistent folder structure, keep track of my packages,
etc.
I was already using Git but I started using
[cookiecutter](https://cookiecutter.readthedocs.io) and Python venv virtual
environments.
However I went crazy on my cookiecutter template and made it overly complicated
and I had difficulty upgrading packages without breaking something.
The last 6 months I have really started to look at my tools and make
improvements.

I believe my biggest issue was that I did not really sit down and figure out my
requirements and the minimum I need to get a project going.
I am hoping that documenting will help me continuously improve my workflow.

## Tools

### Cookiecutter

For right now I only use Cookiecutter when I do my Jupyter Notebook projects.
I currently don't use it for my Python projects.
Instead I just manually build out my project folder, .gitignore, etc.

### Code Editor

I actually use couple different IDEs/editors.
With all my editors, I put my settings/config file in a git repo so that I can
share with all my computers.

#### [VS Code](https://code.visualstudio.com/)

There is a lot of momentum with a lot of people using VS Code.
VS Code has great Python support and more importantly it works on Windows,
Linux and Mac.
VS Code supports a variety of languages as well.
This makes learning one IDE that works everywhere and with most languages.

I use VS Code mainly at work and not much at home despite that I can use it
everywhere.
VS Code is a little heavy and can get slow if you use too many plugins.
Also I lean more towards more to the command-line.
VS Code does have a neat feature to sync settings across multiple computers.

However I readily suggest VS Code when others ask since it is pretty easy to use
and it is pretty popular.

#### [micro](https://micro-editor.github.io)

This replaced vim for me.
Micro is as easy as nano and almost as powerful as vim.
Micro is a terminal-based editor which could be a turn off to some.
Micro does support plugins and with Python it supports syntax highlighting,
linting, auto indenting, etc.

I use micro at home and at work though at work only on my Ubuntu VM.
Micro for Windows is slow while using in Windows Terminal.
Using micro under WSL works fine though.

**Note** that micro is not an IDE but with plugins could be consider a
lightweight IDE.

### Running Multiple Python Versions

I currently have different methods based on OS.

#### Windows

For right now, I download packages from https://python.org and install 
`c:\python\pythonXX-VV` with `XX` being the Python version and `VV` whether it is
32-bit or 64-bit.
The problem with this is that I need to keep on top of minor Python updates.

#### Linux

I primarily use Debian based distros.
Right now I am using the versions that are in the package manager.
My plan is to migrate to [pyenv](https://github.com/pyenv/pyenv) though I don't
have a current use.

### Python Environment

I use Python's standard `venv` for my virtual environments.
I initially tried use to [miniconda](https://docs.conda.io/en/latest/miniconda.html)
for my Python projects but I encounter a couple of issues.
While conda works well for my data analysis (think Jupyter Notebooks), I ran
into problems getting 
[PyInstaller](https://docs.conda.io/en/latest/miniconda.html) to work.
Also conda did not have all the packages I needed so I was still needing to use
pip.

At work, I name my virtual environments `venvXX-VV` to denote the python version
and whether it is 32-bit or 64-bit.
I also typically don't upgrade the packages unless I need to add a new package.
Keep in mind that all my projects at work stay within the intranet.

At home all my virtual environment folders are `venv`.
While I may use Python that comes with the OS, I don't use `apt` to install
packages since it tends to be quite out of date.

For my `requirements.txt` I normally just use `pip freeze`.
I plan to start using [pip-review](https://github.com/jgonggrijp/pip-review) to
help with package upgrades.

I plan on using [pipx](https://pipxproject.github.io/pipx/) for my global
packages like black or flake8.

### Personal Packages

I run a private [PyPi server]({filename}/python/2021-05-08-local_pypi.md) and
create packages using flit
(see [my post]({filename}/python/2021-04-17-create_package.md)).
This has been more recent but my plan is to create more packages.

The problem I have at work is that I have one large package that tries to have
everything and I need to break it up.
This was due to learning how to create packages and my previous method was a
little tedious.

### Testing

I use [pytest](https://docs.pytest.org/) for testing.
However, I don't use the test driven development.
Due to the nature of my work, I typically don't get good requirements so at
least initially, it is an iterative process.

For my home projects, I have been attempting to do a more test driven
development cycle.

## Requirements Gathering

My work projects I typically don't get clear requirements.
My Python projects typically spring from some data analysis project and it may
be more useful to create a program or package.
I will create some initial requirements.
As I get more feedback, I will circle back and update my requirements.

## Execution

I use Gitea (see [my post]({filename}/workflow/2021-03-25-using-git.md)) which
is nice since I have access to an issue tracker and wiki.
I will then create a project for my 1.0 release and milestones for the interim
release.
Then I create issues so I know what I need to work on to meet my milestones.

I use git and git flow to create feature and release branches and work towards
creating a program that meets the minimum requirements.
Then as I start working on 2.0, 3.0, etc. I start adding features.

Prior to a 1.0 release, anything goes.
If I have to make breaking changes, I will as I try to meet the initial
requirements.
After 1.0, minor releases (ex. 1.1) will be minor new features.
Bug fixes (ex. 1.1.1) are usually off the main or master branch.
Major new features, breaking changes, etc. (ex. 2.0).

## Summary

This is what I currently do and will be updating the post throughout this year.
Based on my initial research, I can see using make files to automate some of my
tasks and using tools to help with python packages and python version support.